{
  "hash": "557eb955dcd1875ffd9a062a220ff367",
  "result": {
    "markdown": "---\ntitle: \"Apriori algorithm - Association mining rule\"\nimage: image.jpg\ncategories: [Regras de associação, Clustering, Mineração de dados]\nexecute: \n  eval: false\n---\n\n\n## Apriori association rules\n\nInicialmente são carregadas/instaladas as bibliotecas que serão usadas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacotes <- c(\n  \"arules\",\n  \"tidyverse\",\n  \"arulesViz\",\n  \"skimr\",\n  \"readr\",\n  \"here\",\n  \"readr\",\n  \"here\"\n)\n\nfor(pckgs in pacotes){\n  if(!require(pckgs,character.only = TRUE)) install.packages(pckgs)\n  library(pckgs,character.only = TRUE)\n}\n```\n:::\n\n\n## Descrição dos dados\n\nOs dados disponibilizados descrevem resultados de múltiplas partidas com informações dos jogadores presentes. O objetivo é extrair informações como os melhores/piores jogadores aplicando o algoritmo apriori.\n\n## Pré-processamento dos dados\n\nOs dados são importados e as células sem informação são tratadas como `NA`.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importa o arquivo csv e trata as linhas em branco como NA\nfpath <- here(paste0(mpath,\"_ASSOC_PadelStars.csv\"))\ndat <- read.csv(fpath) %>%\n  na_if(\"\")\n\n# View(dat) # Visualizar o formato dos dados\n\nhead(dat, n = 10)\n```\n:::\n\n\nAs colunas dos jogadores foram renomeadas e a coluna que contém nomes de mais de um jogador foram separadas em três variáveis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Renomeia colunas para facilitar o pré-processamento\ndat_v1 <- dat %>%\n  rename(\n    Jogadores = Jogadore.a.s,\n    Jogador_4 = Jogadore.a.s.1\n  )\n# Separa os jogadores em colunas distintas\ndat_v2 <- dat_v1 %>%\n  separate(Jogadores, c(\"Jogador_1\", \"Jogador_2\", \"Jogador_3\"), sep = \",\")\n```\n:::\n\n\nHá nomes de jogadores repetidos (Alejandro, Carlos e Paula) em algumas das sete primeiras linhas.\n\n\n::: {.cell}\n\n:::\n\n\nAssim, considerando que não há mais de um jogador com o mesmo nome as células com nomes repetidos foram transformadas em `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Adiciona NA nos nomes duplicados\ndat_v2$Jogador_4[1] <- NA # Alejandro\ndat_v2$Jogador_4[3] <- NA # Carlos\ndat_v2$Jogador_4[7] <- NA # Paula\n```\n:::\n\n\nOs nomes com caracteres diferentes do esperado são corrigidos e as células sem informação substituídas por `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Corrige nomes com caracteres diferentes do esperado\ndat_v3 <- dat_v2 %>%\n  mutate(\n    across(-Partida, ~ str_replace_all(., c(\n      \"alejandro\" = \"Alejandro\",\n      \"alejandro\\\\*\" = \"Alejandro\",\n      \"Ariana\\\\*\" = \"Ariana\",\n      \"LÃºcia\" = \"Lucia\",\n      \"Juam\" = \"Juan\",\n      \"ALEJANDRO\" = \"Alejandro\",\n      \"GANHOU\" = \"Ganhou\",\n      \"Alejandro\\\\*\" = \"Alejandro\"\n    ))) %>%\n      mutate_all(na_if, \"\") # subs esp. em branco por NA\n  ) %>%\n  select(-c(\"Partida\", \"X\"))\n```\n:::\n\n\nA função `get_pnames` extrai os nomes de todos os jogadores disponíveis nos dados. Os dados foram ordenados de modo que cada jogador seja uma coluna e a ocorrência deste em uma partida é preenchido com 1 e a ausência com 0. De modo similar, na coluna resultado a ocorrência de uma vitória é caracterizada pelo número 1 e a derrota por 0. A função `get_fdata` retorna as colunas dos jogadores neste formato.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_pnames <- function(data) {\n  # Retorna nomes dos jogadores\n  data %>%\n    distinct(Jogador_1) %>%\n    pull()\n}\nget_fdata <- function(data, nome) {\n  # Retorna os dados mais uma coluna com o nome do jogador\n  # Preenchidas com 1 (presença) e 0 (ausência).\n  dat_bin <- data %>%\n    mutate(\n      !!as.character(nome) := across(\n        starts_with(\"Jogador\"),\n        ~ if_else(grepl(nome, .), 1, 0)\n      )\n    )\n  datbin_v2 <- dat_bin %>%\n    mutate(\n      !!as.character(nome) := rowSums(select(., contains(nome)))\n    ) %>%\n    pull(!!as.character(nome)) %>%\n    as_tibble(.)\n\n  datbin_v2 %>%\n    rename(!!as.character(nome) := value)\n}\n```\n:::\n\n\nAs funções para o tratamento dos dados são usadas e são aplicadas as\\\nmudanças finais da coluna resultado como a transformação de \"Ganhou\" para 1 e \"Perdeu\" para 0, além da transformação das variáveis para a classe fator, necessário para aplicação do algoritmo de mineração usado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nome dos jogadores\nnomes <- get_pnames(dat_v3)\n  # Tratamento dos dados para o formato das transações\n# Retorna dado + nomes dos jogadores preenchidos com 1 e 0\ndat_v4 <- dat_v3\nfor (jogador in nomes) {\n  dat_v4 <- dat_v4 %>%\n    add_column(get_fdata(., jogador))\n}\n# Vitória = 1 Derrota = 0\ndat_v5 <- dat_v4 %>%\n  mutate(\n    across(starts_with(\"Resultado\"), ~ if_else(grepl(\"Ganhou\", .), 1, 0))\n  ) %>%\n  select(all_of(nomes), Resultado)\n# Transformação das colunas para fator\ndat_v6 <- dat_v5 %>%\n  mutate(across(everything(), .fns = as.factor))\n\n# Exporta e importa o csv\n#write_csv(dat_v6,\"assoc_p.csv\")\n# Importa csv\n#dat_v6 <- read_csv(\"assoc_p.csv\") %>% \n# mutate(across(everything(), .fns = as.factor))\n\n#str(dat_v6)\n```\n:::\n\n\n## Aplicação do algoritmo Apriori\n\nA mineração dos itens e das regras foi feita através do algoritmo Apriori que trabalha através da busca de itens frequentes dado um suporte e confiança mínima. O Apriori permite reduzir o número de itens que serão analisados para gerar as regras de associação.\n\nOs critérios usados foram o suporte de $10\\%$ e confiança mínima de $60\\%$. Inicialmente, há o interesse de descobrir combinações de jogadores resultaram em vitória. Isto foi feito definindo o lado `rhs = \"Resultado=1\",` (vitórias) em um dos parâmetros da função `apriori`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregras <- apriori(dat_v6,\n  parameter = list(\n    supp = 0.1,\n    conf = 0.6,\n    minlen = 2,\n    #maxlen = 10,\n    target = \"rules\"\n  ),\n  appearance = list(\n    default = \"lhs\",\n    rhs = \"Resultado=1\"\n  )\n)\n\n#inspect(regras)\n\n#reg1_df <- as(regras,\"data.frame\")\n# reg1_df %>% \n#   arrange(desc(support,confidence)) %>% View()\n```\n:::\n\n\nOs resultados são filtrados para os jogadores que estavam presentes na partida (LHS = 1). Para melhorar a visualização as regras são transformadas em um quadro de dados ordenados pelos maiores valores de lift.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Regras com lhs = 1 e Resultado=1\nreg1_lhs1 <- regras[sapply(as(items(regras), \"list\"), function(x) all(grepl(\"=1$\", x)))]\n# Combinações vencedoras\nr1lhs1_df <- as(reg1_lhs1,\"data.frame\") %>% \n  arrange(desc(confidence)) \n(r1lhs1_df)\n```\n:::\n\n\nO jogador Alejandro obteve a vitória em $66\\%$ das partidas que participou, tendo participado em cerca de $28\\%$ do total de partidas. A melhor dupla é formada por Paula e Alejandro, que obtiveram a vitória em $72\\%$ das partidas que participaram e estiveram presentes em cerca de $12\\%$ do total de partidas.\n\nOs jogadore com os piores resultados é encontrado filtrando as regras para `rhs = \"Resultado=0\"` na função `apriori` e selecionando os jogadores que estiveram presentes nestas derrotas (LHS = 1). Fora o `rhs`, os outros parâmetros não foram alterados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregras_perd <- apriori(dat_v6,\n  parameter = list(\n    supp = 0.1,\n    conf = 0.2,\n    minlen = 2,\n    #maxlen = 10,\n    target = \"rules\"\n  ),\n  appearance = list(\n    default = \"lhs\",\n    rhs = \"Resultado=0\"\n  )\n)\n#inspect(regras_perd)\nreg0_df <- as(regras_perd,\"data.frame\")\n# reg0_df %>% \n#   arrange(desc(support,confidence)) %>% View()\n```\n:::\n\n\nOs resultados são filtrados para as associações com no máximo um jogador, isto foi feito a partir do controle de caracteres de cada string. Por fim, é verificado que os resultados que apresentam os jogadores presentes (LHS=1) estão nas últimas sete linhas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg0_df %>% \n   # Filtra LHS com no máximo um jogador\n  filter(str_length(rules) < 32) %>%\n  arrange(desc(support),desc(confidence)) %>% \n  filter(row_number() >= (n() - 6)) \n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}